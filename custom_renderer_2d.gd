@tool
extends EdgarRenderer2D

func _post_process(tile_map_layer: TileMapLayer, tiled_layer: String) -> void:
	# NOTE: you must manually set your resource_name in resource 'new_tile_set.tres'
	if tile_map_layer.tile_set.resource_name == "new_tile_set":
		var blocks := tile_map_layer.get_used_cells_by_id(0, Vector2(0, 0))
		var platforms := tile_map_layer.get_used_cells_by_id(0, Vector2(1, 0))
		var ladders := tile_map_layer.get_used_cells_by_id(0, Vector2(2, 0))
		var slopes_l := tile_map_layer.get_used_cells_by_id(0, Vector2(3, 0))
		var slopes_r := tile_map_layer.get_used_cells_by_id(0, Vector2(4, 0))
		
		tile_map_layer.clear()
		
		if tiled_layer == "col":
			# NOTE: just ignore tile/room exceptions/inclusions here for simplicity
			for room in layout.rooms:
				if int(room.edgar_layer) != 1:
					continue
				
				tile_map_layer.set_cells_terrain_connect(get_room_cells(room), 0, 0)
				break # only have one limit layer
			
			for room in layout.rooms:
				if int(room.edgar_layer) != 0:
					continue
				
				for cell in get_room_cells(room):
					tile_map_layer.erase_cell(cell)
		
			tile_map_layer.set_cells_terrain_connect(blocks, 0, 0)
			tile_map_layer.set_cells_terrain_connect(platforms, 0, 1)
			tile_map_layer.set_cells_terrain_connect(ladders, 0, 2)
			tile_map_layer.set_cells_terrain_connect(slopes_l, 0, 3)
			tile_map_layer.set_cells_terrain_connect(slopes_r, 0, 4)

# NOTE: we have two types of polygon here
# 1. strong simple polygon for basic room
# 2. weak simple polygon for limit room
# in our limit room, the inner loop was created, then was the outer boundary
# so the inner boundary is what we want
# This depends on your implement / constrain details
func get_room_cells(room: Dictionary) -> Array:
	var _position = room.position
	var _outline := room.outline as PackedVector2Array
	var _take_cnt := 0
	match int(room.edgar_layer):
		0: # combat
			_take_cnt = _outline.size()
		1: # limit
			_take_cnt = int((_outline.size() - 1) / 2.)
		_:
			printerr("Unhandled case when getting room cells!")
	var outline: PackedVector2Array
	outline.resize(_take_cnt)
	
	var i := 0
	while i < _take_cnt:
		outline[i] = _outline[i] + _position
		i += 1
	
	return outline_to_cells(outline)

# NOTE: This section was generated by Gemini 3 using Copilot.
func outline_to_cells(outline: PackedVector2Array) -> PackedVector2Array:
	if outline.size() < 3:
		return []
	
	var rect := Rect2(outline[0], Vector2.ZERO)
	for point in outline:
		rect = rect.expand(point)
	
	var cells: PackedVector2Array
	var start_x := int(floor(rect.position.x))
	var end_x := int(ceil(rect.end.x))
	var start_y := int(floor(rect.position.y))
	var end_y := int(ceil(rect.end.y))
	
	var x := start_x
	while x < end_x:
		var y = start_y
		while y < end_y:
			if Geometry2D.is_point_in_polygon(Vector2(x + 0.5, y + 0.5), outline):
				cells.append(Vector2i(x, y))
			y += 1
		x += 1
	
	return cells
