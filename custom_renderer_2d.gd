@tool
extends EdgarRenderer2D

func _post_process(id: int, tile_map_layer: TileMapLayer) -> void:
	match id:
		1:
			var blocks := tile_map_layer.get_used_cells_by_id(0, Vector2(0, 0))
			var platforms := tile_map_layer.get_used_cells_by_id(0, Vector2(1, 0))
			var ladders := tile_map_layer.get_used_cells_by_id(0, Vector2(2, 0))
			var slopes_l := tile_map_layer.get_used_cells_by_id(0, Vector2(3, 0))
			var slopes_r := tile_map_layer.get_used_cells_by_id(0, Vector2(4, 0))
			
			tile_map_layer.clear()
			
			# NOTE: just ignore tile/room exceptions/inclusions here for simplicity
			for room in layout.rooms:
				if int(room.edgar_layer) != 1:
					continue
				
				tile_map_layer.set_cells_terrain_connect(get_room_cells(room, tile_map_layer), 0, 0)
				break # only have one limit layer
			
			for room in layout.rooms:
				if int(room.edgar_layer) != 0:
					continue
				
				for cell in get_room_cells(room, tile_map_layer):
					tile_map_layer.erase_cell(cell)
			
			tile_map_layer.set_cells_terrain_connect(blocks, 0, 0)
			tile_map_layer.set_cells_terrain_connect(platforms, 0, 1)
			tile_map_layer.set_cells_terrain_connect(ladders, 0, 2)
			tile_map_layer.set_cells_terrain_connect(slopes_l, 0, 3)
			tile_map_layer.set_cells_terrain_connect(slopes_r, 0, 4)
		_:
			pass

# NOTE: we have two types of polygon here
# 1. strong simple polygon for basic room
# 2. weak simple polygon for limit room
# in our limit room, the inner loop was created, then was the outer boundary
# so the inner boundary is what we want
# This depends on your implement / constrain details
func get_room_cells(room: Dictionary, tile_map_layer: TileMapLayer) -> Array:
	var _position = room.position
	var _outline := room.outline as Array
	var _take_cnt := 0
	match int(room.edgar_layer):
		0: # combat
			_take_cnt = _outline.size()
		1: # limit
			_take_cnt = int((_outline.size() - 1) / 2.)
		_:
			printerr("Unhandled case when getting room cells!")
	var outline := []
	for i in range(_take_cnt):
		outline.push_back((_outline[i] + _position) / Vector2(tile_map_layer.tile_set.tile_size))
	
	return outline_to_cells(outline)

# NOTE: This section was generated by Gemini 3 using Copilot.
func outline_to_cells(outline: Array) -> Array[Vector2i]:
	var polygon := PackedVector2Array(outline)
	if polygon.size() < 3:
		return []
	
	var rect := Rect2(polygon[0], Vector2.ZERO)
	for point in polygon:
		rect = rect.expand(point)
	
	var cells: Array[Vector2i] = []
	var start_x := int(floor(rect.position.x))
	var end_x := int(ceil(rect.end.x))
	var start_y := int(floor(rect.position.y))
	var end_y := int(ceil(rect.end.y))
	
	for x in range(start_x, end_x):
		for y in range(start_y, end_y):
			if Geometry2D.is_point_in_polygon(Vector2(x + 0.5, y + 0.5), polygon):
				cells.append(Vector2i(x, y))
	
	return cells
